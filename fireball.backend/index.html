<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fireball</title>
    <meta name="description" content="A rapid and strategic alternative to Rock-Paper-Scissors">
    <link rel="icon" type="image/svg+xml" href="/fireball_logo.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito+Sans:opsz,wght@6..12,400;6..12,500;6..12,600;6..12,700;6..12,800&display=swap"
        rel="stylesheet">

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase SDK (v9 modular) -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getFirestore } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

        // Firebase config - this must match your Firebase project
        // We'll fetch this from the backend to keep credentials secure
        window.initFirebase = async function () {
            try {
                const res = await fetch('/api/auth?action=firebase_config');
                const config = await res.json();

                if (config.error) {
                    console.warn('Firebase client config not available, falling back to polling');
                    window.firebaseApp = null;
                    window.firestoreDb = null;
                    return;
                }

                window.firebaseApp = initializeApp(config);
                window.firestoreDb = getFirestore(window.firebaseApp);
                console.log('Firebase initialized for real-time listeners');
            } catch (e) {
                console.warn('Failed to initialize Firebase client:', e);
                window.firebaseApp = null;
                window.firestoreDb = null;
            }
        };

        // Initialize on load
        window.initFirebase();
    </script>

    <style>
        :root {
            --fire-red: #dc2626;
            --fire-orange: #ea580c;
            --fire-amber: #f59e0b;
            --accent-purple: #7c3aed;
            --accent-indigo: #4f46e5;
            --bg-primary: #0c0a14;
            --bg-secondary: #14101f;
            --bg-card: #1a1528;
            --bg-card-hover: #221d32;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-subtle: rgba(255, 255, 255, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .app {
            min-height: 100vh;
            padding: 2rem;
        }

        /* Homepage */
        .home-container {
            min-height: calc(100vh - 4rem);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 12vh;
            gap: 3rem;
        }

        .home-header {
            text-align: center;
        }

        .home-logo {
            width: 80px;
            height: 80px;
            margin-bottom: 1rem;
        }

        .home-title {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--fire-red), var(--fire-orange), var(--fire-amber));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .home-subtitle {
            color: var(--text-secondary);
            font-size: 1.125rem;
            margin-top: 0.5rem;
        }

        .home-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            max-width: 900px;
            width: 100%;
        }

        .home-card {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            padding: 2.5rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .home-card:hover {
            background: var(--bg-card-hover);
            transform: translateY(-4px);
            border-color: var(--fire-orange);
        }

        .home-card-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
        }

        .home-card-desc {
            color: var(--text-secondary);
            font-size: 0.9375rem;
        }

        .admin-trigger {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 32px;
            height: 32px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 4px;
            cursor: pointer;
            opacity: 0.3;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        .admin-trigger:hover {
            opacity: 1;
        }

        /* Game page */
        .game-container {
            max-width: 700px;
            margin: 0 auto;
        }

        .game-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .game-logo {
            width: 48px;
            height: 48px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .game-logo:hover {
            transform: scale(1.05);
        }

        .game-title {
            font-size: 1.75rem;
            font-weight: 700;
        }

        .back-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.9375rem;
            font-family: inherit;
            margin-left: auto;
        }

        .back-btn:hover {
            color: var(--text-primary);
        }

        .charge-display {
            display: flex;
            justify-content: space-between;
            padding: 2rem 3rem;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            margin-bottom: 2rem;
        }

        .charge-block {
            text-align: center;
            flex: 1;
        }

        .charge-label {
            font-size: 0.8125rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .charge-value {
            font-size: 4rem;
            font-weight: 800;
            line-height: 1;
        }

        .player-charge .charge-label {
            color: var(--fire-orange);
        }

        .opponent-charge .charge-label {
            color: var(--accent-purple);
        }

        .moves-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
        }

        .move-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1.5rem 0.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .move-btn:hover:not(:disabled) {
            background: var(--bg-card-hover);
            border-color: var(--fire-orange);
        }

        .move-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .move-btn.selected {
            border: 2px solid var(--fire-orange);
            background: var(--bg-card-hover);
            opacity: 1 !important;
            box-shadow: 0 0 10px rgba(234, 88, 12, 0.2);
        }

        .move-btn.faded {
            opacity: 0.2;
            filter: grayscale(1);
            transform: scale(0.95);
        }

        .move-btn .cost {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 400;
        }

        .history-section {
            margin-top: 2.5rem;
        }

        .history-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            font-size: 0.875rem;
        }

        .history-item span {
            color: var(--text-secondary);
        }

        .history-item .you {
            color: var(--fire-orange);
        }

        .history-item .opp {
            color: var(--accent-purple);
        }

        /* End game */
        .end-game-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(15, 15, 20, 0.95), rgba(10, 10, 15, 0.95));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid;
            border-radius: 24px;
            padding: 0;
            text-align: center;
            z-index: 10000;
            box-shadow:
                0 25px 70px rgba(0, 0, 0, 0.6),
                inset 0 1px 1px rgba(255, 255, 255, 0.1);
            animation: slideDownBounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            min-width: 380px;
            max-width: 420px;
        }

        @keyframes slideDownBounce {
            0% {
                transform: translate(-50%, -60%);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .end-game-overlay.win {
            border-color: var(--fire-orange);
            box-shadow:
                0 25px 70px rgba(0, 0, 0, 0.6),
                0 0 50px rgba(234, 88, 12, 0.25),
                inset 0 1px 1px rgba(255, 255, 255, 0.1);
        }

        .end-game-overlay.lose {
            border-color: rgba(150, 150, 170, 0.4);
        }

        .end-game-content {
            padding: 2.5rem 2rem 2rem;
        }

        .end-icon {
            font-size: 5rem;
            margin-bottom: 1rem;
            animation: iconPop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s both;
            line-height: 1;
        }

        @keyframes iconPop {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .end-title {
            font-size: 2.5rem;
            font-weight: 800;
            margin: 0 0 0.5rem 0;
            letter-spacing: -0.02em;
        }

        .end-title.win {
            color: var(--fire-orange);
            text-shadow: 0 0 30px rgba(234, 88, 12, 0.4);
        }

        .end-title.lose {
            color: var(--text-muted);
        }

        .end-subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
            margin: 0 0 2rem 0;
        }

        .end-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .end-actions .btn {
            flex: 1;
            max-width: 160px;
            padding: 0.875rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
        }

        .play-again-btn {
            position: relative;
            overflow: hidden;
        }

        .play-again-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .play-again-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .close-overlay-btn {
            position: absolute;
            top: 1.25rem;
            right: 1.25rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            font-size: 1.25rem;
            cursor: pointer;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .close-overlay-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .close-overlay-btn:active {
            transform: scale(0.95);
        }

        .play-again-header {
            margin-top: 1rem;
        }

        @keyframes slideDown {
            from {
                transform: translate(-50%, -60%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .end-game {
            text-align: center;
            padding: 3rem 2rem;
        }

        .end-title {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .end-title.win {
            color: var(--fire-orange);
            text-shadow: 0 0 30px rgba(234, 88, 12, 0.5);
        }

        .end-title.lose {
            color: var(--text-secondary);
        }

        .end-subtitle {
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }

        .btn {
            padding: 1rem 2rem;
            font-family: inherit;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--fire-red), var(--fire-orange));
            color: white;
        }

        .btn-primary:hover {
            filter: brightness(1.1);
        }

        .btn-secondary {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            color: var(--text-primary);
        }

        /* Guide page */
        .guide-container {
            max-width: 700px;
            margin: 0 auto;
        }

        .guide-content {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            padding: 2.5rem;
        }

        .guide-content h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .guide-content h3 {
            font-size: 1.125rem;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
            color: var(--fire-orange);
        }

        .guide-content p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .guide-content ul {
            list-style: none;
            padding: 0;
        }

        .guide-content li {
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-subtle);
            color: var(--text-secondary);
        }

        .guide-content li:last-child {
            border-bottom: none;
        }

        .guide-content strong {
            color: var(--text-primary);
        }

        /* 1v1 */
        .matchmaking-status {
            text-align: center;
            padding: 3rem;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
        }

        .matchmaking-status p {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .input-field {
            width: 100%;
            max-width: 300px;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-purple);
        }

        /* Stats modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
        }

        .modal h3 {
            margin-bottom: 1.5rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            font-weight: 700;
        }

        /* Alert */
        .alert {
            padding: 1rem;
            background: rgba(220, 38, 38, 0.15);
            border: 1px solid rgba(220, 38, 38, 0.3);
            color: #fca5a5;
            margin-bottom: 1.5rem;
        }

        /* Loader */
        .loader {
            width: 32px;
            height: 32px;
            border: 3px solid var(--bg-secondary);
            border-top-color: var(--fire-orange);
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Online players badge */
        .online-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .online-dot {
            width: 8px;
            height: 8px;
            background: #22c55e;
            border-radius: 50%;
            animation: pulse-dot 2s ease-in-out infinite;
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Waiting for opponent animation */
        .waiting-overlay {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            margin-top: 1.5rem;
        }

        .waiting-text {
            color: var(--text-secondary);
            font-size: 1rem;
            margin-top: 1rem;
            animation: fade-pulse 1.5s ease-in-out infinite;
        }

        @keyframes fade-pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }

        .waiting-dots {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .waiting-dots span {
            width: 10px;
            height: 10px;
            background: var(--fire-orange);
            border-radius: 50%;
            animation: bounce-dot 1.4s ease-in-out infinite;
        }

        .waiting-dots span:nth-child(1) {
            animation-delay: 0s;
        }

        .waiting-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .waiting-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes bounce-dot {

            0%,
            80%,
            100% {
                transform: translateY(0);
                opacity: 0.5;
            }

            40% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        /* Warning box for no players online */
        .warning-box {
            padding: 1rem;
            background: rgba(220, 38, 38, 0.08);
            border: 1px solid rgba(220, 38, 38, 0.4);
            border-radius: 4px;
            color: #fca5a5;
            font-size: 0.875rem;
            margin-top: 1.5rem;
            text-align: center;
            animation: fade-in 0.3s ease;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Disconnected overlay */
        .disconnected-overlay {
            text-align: center;
            padding: 3rem;
            background: var(--bg-card);
            border: 1px solid rgba(220, 38, 38, 0.4);
        }

        .disconnected-overlay h2 {
            color: #fca5a5;
            margin-bottom: 1rem;
        }

        .disconnected-overlay p {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .app {
                padding: 1rem;
            }

            .home-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .home-title {
                font-size: 2rem;
            }

            .moves-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .charge-display {
                padding: 1.5rem;
            }

            .charge-value {
                font-size: 3rem;
            }

            .guide-content {
                padding: 1.5rem;
            }
        }

        @media (max-width: 480px) {
            .moves-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>


    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        const { createRoot } = ReactDOM;

        // Admin token stored in sessionStorage (not exposed in JS variables)
        const getAdminToken = () => sessionStorage.getItem('fireball_admin_token');
        const setAdminToken = (token) => sessionStorage.setItem('fireball_admin_token', token);
        const clearAdminToken = () => sessionStorage.removeItem('fireball_admin_token');

        const MOVES = [
            { id: 'charge', name: 'Charge', cost: 0, costDisplay: '+1' },
            { id: 'shield', name: 'Shield', cost: 0, costDisplay: '0' },
            { id: 'fireball', name: 'Fireball', cost: 1, costDisplay: '-1' },
            { id: 'iceball', name: 'Iceball', cost: 2, costDisplay: '-2' },
            { id: 'megaball', name: 'Megaball', cost: 5, costDisplay: '-5' }
        ];

        const getLegalMoves = (charges) => {
            return MOVES.filter(m => {
                if (m.id === 'charge' || m.id === 'shield') return true;
                return charges >= m.cost;
            }).map(m => m.id);
        };

        async function sha256(message) {
            const msgBuffer = new TextEncoder().encode(message);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Generate or retrieve persistent user ID for tracking unique browsers
        function getOrCreateUserId() {
            let userId = localStorage.getItem('fireball_user_id');
            if (!userId) {
                userId = 'user' + Math.floor(Math.random() * 10000) + 1;
                localStorage.setItem('fireball_user_id', userId);
            }
            return userId;
        }

        function MaintenancePage({ message }) {
            return (
                <div style={{
                    minHeight: '100vh',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    padding: '2rem',
                    textAlign: 'center'
                }}>
                    <img
                        src="/fireball_logo.png"
                        alt="Fireball Logo"
                        style={{ width: '200px', height: '200px', marginBottom: '2rem' }}
                    />
                    <p style={{
                        color: 'white',
                        fontSize: '1.5rem',
                        maxWidth: '600px',
                        lineHeight: '1.8',
                        whiteSpace: 'pre-wrap'
                    }}>
                        {message || 'Site undergoing temporary maintenance. Please check back later.'}
                    </p>
                </div>
            );
        }

        function HomePage({ onNavigate }) {
            return (
                <div className="home-container">
                    <div className="home-header">
                        <img src="/fireball_logo.png" alt="Fireball" className="home-logo" />
                        <h1 className="home-title">Fireball</h1>
                        <p className="home-subtitle">A fun, strategic, and fast-paced game</p>
                    </div>

                    <div className="home-grid">
                        <div className="home-card" onClick={() => onNavigate('play-ai')}>
                            <h2 className="home-card-title">Play vs ML Model</h2>
                            <p className="home-card-desc">Play against a ML bot that analyzes common patterns</p>
                        </div>

                        <div className="home-card" onClick={() => onNavigate('guide')}>
                            <h2 className="home-card-title">How to Play</h2>
                            <p className="home-card-desc">Learn the rules!</p>
                        </div>

                        <div className="home-card" onClick={() => onNavigate('play-1v1')}>
                            <h2 className="home-card-title">Play Online</h2>
                            <p className="home-card-desc">Real-time matches against other players</p>
                        </div>
                    </div>

                    <button className="admin-trigger" onClick={() => onNavigate('admin')}>
                        ðŸ’Ž
                    </button>
                </div>
            );
        }

        function WinRateChart({ mlStatus, chartTimeframe, setChartTimeframe }) {
            const [hoveredPoint, setHoveredPoint] = useState(null);
            const now = new Date();
            const daysMap = { '1d': 1, '7d': 7, '30d': 30, '90d': 90, '6mo': 180 };
            const days = daysMap[chartTimeframe] || 30;
            const cutoffDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
            const cutoffStr = cutoffDate.toISOString().slice(0, 10);
            const filteredData = mlStatus.historical_win_rates.filter(d => d.date >= cutoffStr);

            // Get all-time stats from training_data
            const allTimeWinRate = mlStatus.training_data?.ai_win_rate || 0;
            const allTimeGames = mlStatus.training_data?.ai_vs_human_games || 0;

            if (filteredData.length === 0) {
                return <p style={{ color: 'var(--text-muted)', textAlign: 'center', padding: '2rem' }}>No data for this timeframe</p>;
            }

            // Calculate stats from the filtered data (for selected period)
            const periodGames = filteredData.reduce((sum, d) => sum + d.total, 0);
            const periodWins = filteredData.reduce((sum, d) => sum + d.wins, 0);
            const periodWinRate = periodGames > 0 ? (periodWins / periodGames * 100) : 0;

            // For trend calculation: compare first half vs second half of period
            const midpoint = Math.floor(filteredData.length / 2);
            const firstHalf = filteredData.slice(0, midpoint);
            const secondHalf = filteredData.slice(midpoint);

            const firstHalfGames = firstHalf.reduce((sum, d) => sum + d.total, 0);
            const firstHalfWins = firstHalf.reduce((sum, d) => sum + d.wins, 0);
            const firstHalfRate = firstHalfGames > 0 ? (firstHalfWins / firstHalfGames * 100) : 0;

            const secondHalfGames = secondHalf.reduce((sum, d) => sum + d.total, 0);
            const secondHalfWins = secondHalf.reduce((sum, d) => sum + d.wins, 0);
            const secondHalfRate = secondHalfGames > 0 ? (secondHalfWins / secondHalfGames * 100) : 0;

            const trend = secondHalfRate - firstHalfRate;
            const isPositive = trend >= 0;

            const chartWidth = 750;
            const chartHeight = 280;
            const padding = { top: 40, right: 30, bottom: 50, left: 55 };
            const innerWidth = chartWidth - padding.left - padding.right;
            const innerHeight = chartHeight - padding.top - padding.bottom;

            const maxRate = Math.min(100, Math.max(...filteredData.map(d => d.winRate)) + 10);
            const minRate = Math.max(0, Math.min(...filteredData.map(d => d.winRate)) - 10);

            const points = filteredData.map((d, i) => ({
                x: padding.left + (i / Math.max(filteredData.length - 1, 1)) * innerWidth,
                y: padding.top + innerHeight - ((d.winRate - minRate) / (maxRate - minRate || 1)) * innerHeight,
                ...d
            }));

            const linePath = points.length > 1
                ? points.reduce((acc, p, i, arr) => {
                    if (i === 0) return `M ${p.x} ${p.y}`;
                    const prev = arr[i - 1];
                    const cpx = (prev.x + p.x) / 2;
                    return `${acc} C ${cpx} ${prev.y}, ${cpx} ${p.y}, ${p.x} ${p.y}`;
                }, '')
                : `M ${points[0]?.x || 0} ${points[0]?.y || 0}`;

            const areaPath = `${linePath} L ${points[points.length - 1]?.x || 0} ${chartHeight - padding.bottom} L ${padding.left} ${chartHeight - padding.bottom} Z`;

            const lineColor = '#00C805';
            const gradientId = `winRateGradient_${chartTimeframe}`;
            const periodLabel = chartTimeframe === '6mo' ? 'Last 6 Months' : `Last ${chartTimeframe.toUpperCase()}`;

            return (
                <div style={{ marginTop: '2rem' }}>
                    {/* Header Stats - Now clearly labeled as period stats */}
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(4, 1fr)',
                        gap: '1rem',
                        marginBottom: '1.5rem',
                        background: 'var(--bg-secondary)',
                        borderRadius: '8px',
                        padding: '1rem'
                    }}>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '1.75rem', fontWeight: 700, color: 'white' }}>
                                {periodWinRate.toFixed(1)}%
                            </div>
                            <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginTop: '0.25rem' }}>
                                Win Rate ({periodLabel})
                            </div>
                        </div>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '1.75rem', fontWeight: 700, color: 'white' }}>
                                {periodGames}
                            </div>
                            <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginTop: '0.25rem' }}>
                                Games ({periodLabel})
                            </div>
                        </div>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '1.75rem', fontWeight: 700, color: 'white' }}>
                                {periodWins}
                            </div>
                            <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginTop: '0.25rem' }}>
                                AI Wins ({periodLabel})
                            </div>
                        </div>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{
                                fontSize: '1.75rem',
                                fontWeight: 700,
                                color: isPositive ? '#22c55e' : '#ef4444'
                            }}>
                                {isPositive ? '+' : ''}{trend.toFixed(1)}%
                            </div>
                            <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginTop: '0.25rem' }}>
                                Trend
                            </div>
                        </div>
                    </div>

                    {/* Chart Area */}
                    <div style={{ background: 'var(--bg-secondary)', borderRadius: '12px', padding: '1.5rem', position: 'relative' }}>
                        <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginBottom: '0.5rem' }}>
                            Daily Win Rate
                        </div>

                        {/* Hover Tooltip */}
                        {hoveredPoint && (
                            <div style={{
                                position: 'absolute',
                                left: hoveredPoint.x + 10,
                                top: hoveredPoint.y - 60,
                                background: 'rgba(0,0,0,0.9)',
                                border: '1px solid var(--fire-orange)',
                                borderRadius: '8px',
                                padding: '0.75rem 1rem',
                                zIndex: 100,
                                pointerEvents: 'none',
                                minWidth: '150px'
                            }}>
                                <div style={{ fontWeight: 600, color: 'white', marginBottom: '0.25rem' }}>
                                    {new Date(hoveredPoint.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                                </div>
                                <div style={{ color: lineColor, fontSize: '1.25rem', fontWeight: 700 }}>
                                    {hoveredPoint.winRate}%
                                </div>
                                <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>
                                    {hoveredPoint.wins} wins / {hoveredPoint.total} games
                                </div>
                            </div>
                        )}

                        <svg width="100%" height={chartHeight} viewBox={`0 0 ${chartWidth} ${chartHeight}`} preserveAspectRatio="xMidYMid meet">
                            <defs>
                                <linearGradient id={gradientId} x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stopColor={lineColor} stopOpacity="0.3" />
                                    <stop offset="100%" stopColor={lineColor} stopOpacity="0" />
                                </linearGradient>
                            </defs>

                            {[0, 20, 40, 60, 80, 100].filter(v => v >= minRate && v <= maxRate).map(pct => {
                                const y = padding.top + innerHeight - ((pct - minRate) / (maxRate - minRate || 1)) * innerHeight;
                                return (
                                    <g key={pct}>
                                        <line x1={padding.left} y1={y} x2={chartWidth - padding.right} y2={y} stroke="rgba(255,255,255,0.1)" />
                                        <text x={padding.left - 10} y={y + 4} fill="var(--text-muted)" fontSize="11" textAnchor="end">{pct}%</text>
                                    </g>
                                );
                            })}

                            {/* Average line */}
                            {(() => {
                                const avgY = padding.top + innerHeight - ((periodWinRate - minRate) / (maxRate - minRate || 1)) * innerHeight;
                                return (
                                    <g>
                                        <line x1={padding.left} y1={avgY} x2={chartWidth - padding.right} y2={avgY} stroke="var(--fire-orange)" strokeDasharray="6,4" strokeOpacity="0.6" />
                                        <text x={chartWidth - padding.right + 8} y={avgY + 4} fill="var(--fire-orange)" fontSize="10">Avg</text>
                                    </g>
                                );
                            })()}

                            <path d={areaPath} fill={`url(#${gradientId})`} />
                            <path d={linePath} fill="none" stroke={lineColor} strokeWidth="2.5" strokeLinecap="round" />

                            {points.map((p, i) => (
                                <g
                                    key={i}
                                    style={{ cursor: 'pointer' }}
                                    onMouseEnter={() => setHoveredPoint(p)}
                                    onMouseLeave={() => setHoveredPoint(null)}
                                >
                                    <circle
                                        cx={p.x}
                                        cy={p.y}
                                        r={hoveredPoint?.date === p.date ? 8 : 5}
                                        fill={lineColor}
                                        stroke="var(--bg-secondary)"
                                        strokeWidth="2"
                                        style={{ transition: 'r 0.15s ease' }}
                                    />
                                </g>
                            ))}

                            {(() => {
                                const labelCount = Math.min(7, filteredData.length);
                                const step = Math.max(1, Math.floor(filteredData.length / labelCount));
                                return filteredData.filter((_, i) => i % step === 0 || i === filteredData.length - 1).map((d, idx) => {
                                    const origIdx = filteredData.indexOf(d);
                                    const x = points[origIdx]?.x || 0;
                                    const dateStr = new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                                    return (
                                        <text key={idx} x={x} y={chartHeight - 15} fill="var(--text-muted)" fontSize="11" textAnchor="middle">
                                            {dateStr}
                                        </text>
                                    );
                                });
                            })()}
                        </svg>
                    </div>

                    {/* Timeframe Selector */}
                    <div style={{ display: 'flex', justifyContent: 'center', gap: '0.5rem', marginTop: '1rem' }}>
                        {['1d', '7d', '30d', '90d', '6mo'].map(tf => (
                            <button
                                key={tf}
                                onClick={() => setChartTimeframe(tf)}
                                style={{
                                    padding: '0.5rem 1rem',
                                    fontSize: '0.8rem',
                                    fontWeight: chartTimeframe === tf ? 600 : 400,
                                    background: chartTimeframe === tf ? 'var(--fire-orange)' : 'transparent',
                                    border: chartTimeframe === tf ? 'none' : '1px solid var(--border-subtle)',
                                    color: chartTimeframe === tf ? 'white' : 'var(--text-secondary)',
                                    cursor: 'pointer',
                                    borderRadius: '20px',
                                    transition: 'all 0.2s ease'
                                }}
                            >{tf.toUpperCase()}</button>
                        ))}
                    </div>
                </div>
            );
        }

        function AdminPage({ onNavigate }) {
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [isCheckingAuth, setIsCheckingAuth] = useState(true);
            const [password, setPassword] = useState('');
            const [loginError, setLoginError] = useState('');
            const [stats, setStats] = useState(null);
            const [mlStatus, setMlStatus] = useState(null);
            const [loading, setLoading] = useState(false);
            const [activeTab, setActiveTab] = useState('overview');
            const [chartTimeframe, setChartTimeframe] = useState('30d');
            const [maintenanceMode, setMaintenanceMode] = useState(false);
            const [maintenanceLoading, setMaintenanceLoading] = useState(false);


            // Check if we have a valid token on mount
            useEffect(() => {
                const checkAuth = async () => {
                    const token = getAdminToken();
                    if (!token) {
                        setIsCheckingAuth(false);
                        return;
                    }

                    try {
                        const res = await fetch('/api/auth?action=verify', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            }
                        });
                        const data = await res.json();

                        if (data.valid) {
                            setIsAuthenticated(true);
                            fetchStats();
                            fetchMlStatus();
                            fetchMaintenanceStatus();
                        } else {
                            clearAdminToken();
                        }
                    } catch (e) {
                        clearAdminToken();
                    }
                    setIsCheckingAuth(false);
                };

                checkAuth();
            }, []);

            const handleLogin = async () => {
                setLoginError('');

                // Hash password client-side using SHA-256
                const hash = await sha256(password);

                try {
                    const res = await fetch('/api/auth?action=login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ passwordHash: hash })
                    });

                    const data = await res.json();

                    if (data.success && data.token) {
                        setAdminToken(data.token);
                        setIsAuthenticated(true);
                        setPassword('');
                        fetchStats();
                        fetchMlStatus();
                        fetchMaintenanceStatus();
                    } else {
                        setLoginError(data.error || 'Incorrect password');
                    }
                } catch (e) {
                    setLoginError('Failed to connect to server');
                }
            };

            const handleLogout = async () => {
                const token = getAdminToken();
                if (token) {
                    await fetch('/api/auth?action=logout', {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                }
                clearAdminToken();
                setIsAuthenticated(false);
                setStats(null);
                setMlStatus(null);
            };

            const fetchStats = async () => {
                setLoading(true);
                try {
                    const token = getAdminToken();
                    const res = await fetch('/api/stats', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });

                    if (res.status === 401) {
                        clearAdminToken();
                        setIsAuthenticated(false);
                        return;
                    }

                    const data = await res.json();
                    setStats(data);
                } catch (e) {
                    setStats({ error: 'Failed to load stats' });
                }
                setLoading(false);
            };

            const fetchMlStatus = async () => {
                try {
                    const token = getAdminToken();
                    const res = await fetch('/api/ml_manage', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const data = await res.json();
                    setMlStatus(data);
                } catch (e) {
                    console.log('ML status not available');
                }
            };

            const fetchMaintenanceStatus = async () => {
                try {
                    const res = await fetch('/api/auth?action=config');
                    const data = await res.json();
                    setMaintenanceMode(data.maintenance_mode || false);
                } catch (e) {
                    console.log('Failed to fetch maintenance status');
                }
            };

            const toggleMaintenanceMode = async () => {
                setMaintenanceLoading(true);
                try {
                    const token = getAdminToken();
                    const res = await fetch('/api/auth?action=set_maintenance', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ enabled: !maintenanceMode })
                    });

                    const data = await res.json();
                    if (data.success) {
                        setMaintenanceMode(!maintenanceMode);
                    } else {
                        alert(data.error || 'Failed to toggle maintenance mode');
                    }
                } catch (e) {
                    alert('Failed to connect to server');
                }
                setMaintenanceLoading(false);
            };

            const uploadOriginalModel = async () => {
                try {
                    const token = getAdminToken();
                    const res = await fetch('/api/ml_manage', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ action: 'upload_original' })
                    });
                    const data = await res.json();
                    alert(data.message || 'Done');
                    fetchMlStatus();
                } catch (e) {
                    alert('Failed to upload model');
                }
            };

            if (isCheckingAuth) {
                return (
                    <div className="game-container">
                        <div className="game-header">
                            <img src="/fireball_logo.png" alt="" className="game-logo" />
                            <h1 className="game-title">Admin Panel</h1>
                        </div>
                        <div style={{ textAlign: 'center', padding: '3rem' }}>
                            <div className="loader"></div>
                            <p style={{ color: 'var(--text-secondary)', marginTop: '1rem' }}>Checking authentication...</p>
                        </div>
                    </div>
                );
            }

            if (!isAuthenticated) {
                return (
                    <div className="game-container">
                        <div className="game-header">
                            <img src="/fireball_logo.png" alt="" className="game-logo" />
                            <h1 className="game-title">Admin Panel</h1>
                            <button className="back-btn" onClick={() => onNavigate('home')}>Back</button>
                        </div>
                        <div className="matchmaking-status">
                            <p>Enter admin password to continue</p>
                            {loginError && (
                                <div className="alert" style={{ marginBottom: '1rem', maxWidth: '300px', margin: '0 auto 1rem' }}>
                                    {loginError}
                                </div>
                            )}
                            <input
                                type="password"
                                className="input-field"
                                placeholder="Password"
                                value={password}
                                onChange={e => setPassword(e.target.value)}
                                onKeyDown={e => e.key === 'Enter' && handleLogin()}
                            />
                            <br />
                            <button className="btn btn-primary" onClick={handleLogin}>Login</button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="game-container" style={{ maxWidth: '1200px' }}>
                    <div className="game-header">
                        <img src="/fireball_logo.png" alt="" className="game-logo" onClick={() => onNavigate('home')} />
                        <h1 className="game-title">Admin Dashboard</h1>
                        <div style={{ marginLeft: 'auto', display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                            <button className="back-btn" onClick={handleLogout} style={{ color: '#fca5a5' }}>Logout</button>
                            <button className="back-btn" onClick={() => onNavigate('home')}>Back</button>
                        </div>
                    </div>

                    {/* Maintenance Mode Banner */}
                    {maintenanceMode && (
                        <div style={{
                            background: 'rgba(220, 38, 38, 0.15)',
                            border: '1px solid rgba(220, 38, 38, 0.3)',
                            padding: '0.75rem 1rem',
                            marginBottom: '1.5rem',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'space-between'
                        }}>
                            <span style={{ color: '#fca5a5' }}>Maintenance Mode is ON - Users cannot access the site</span>
                            <button
                                className="btn btn-secondary"
                                onClick={toggleMaintenanceMode}
                                disabled={maintenanceLoading}
                                style={{ padding: '0.5rem 1rem', fontSize: '0.85rem' }}
                            >
                                {maintenanceLoading ? 'Updating...' : 'Disable'}
                            </button>
                        </div>
                    )}

                    {loading ? (
                        <div style={{ textAlign: 'center', padding: '3rem' }}>
                            <div className="loader"></div>
                        </div>
                    ) : stats && !stats.error ? (
                        <>
                            <div style={{ display: 'flex', gap: '1rem', marginBottom: '2rem', flexWrap: 'wrap' }}>
                                <button
                                    className={`btn ${activeTab === 'overview' ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setActiveTab('overview')}
                                >Overview</button>
                                <button
                                    className={`btn ${activeTab === 'ai-games' ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setActiveTab('ai-games')}
                                >Bot Games ({stats.aiGames === 'ERROR' ? '!' : (stats.aiGames || 0)})</button>
                                <button
                                    className={`btn ${activeTab === 'online-games' ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setActiveTab('online-games')}
                                >Online Games ({stats.totalOnlineGames === 'ERROR' ? '!' : (stats.totalOnlineGames || 0)})</button>
                                <button
                                    className={`btn ${activeTab === 'ml-status' ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => { setActiveTab('ml-status'); fetchMlStatus(); }}
                                >ML Status</button>
                                <button
                                    className={`btn ${activeTab === 'settings' ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setActiveTab('settings')}
                                >Settings</button>
                            </div>

                            {activeTab === 'settings' && (
                                <div style={{ display: 'grid', gap: '1.5rem' }}>
                                    <div className="home-card" style={{ cursor: 'default', padding: '1.5rem' }}>
                                        <h3 style={{ marginBottom: '1rem', color: 'var(--fire-orange)' }}>Site Settings</h3>
                                        <div style={{ display: 'grid', gap: '1rem' }}>
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center',
                                                padding: '1rem',
                                                background: 'var(--bg-secondary)',
                                                borderRadius: '8px'
                                            }}>
                                                <div>
                                                    <strong style={{ color: 'var(--text-primary)' }}>Maintenance Mode</strong>
                                                    <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginTop: '0.25rem' }}>
                                                        When enabled, users will see a maintenance page instead of the game.
                                                    </p>
                                                </div>
                                                <button
                                                    className={`btn ${maintenanceMode ? 'btn-primary' : 'btn-secondary'}`}
                                                    onClick={toggleMaintenanceMode}
                                                    disabled={maintenanceLoading}
                                                    style={{
                                                        minWidth: '100px',
                                                        background: maintenanceMode ? '#dc2626' : undefined
                                                    }}
                                                >
                                                    {maintenanceLoading ? '...' : (maintenanceMode ? 'ON' : 'OFF')}
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {activeTab === 'ml-status' && (
                                <div style={{ display: 'grid', gap: '1.5rem' }}>
                                    <div className="home-card" style={{ cursor: 'default', padding: '1.5rem' }}>
                                        <h3 style={{ marginBottom: '1rem', color: 'var(--fire-orange)' }}>ML Training System</h3>
                                        {mlStatus ? (
                                            <div style={{ display: 'grid', gap: '0.75rem', fontSize: '0.9rem' }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                    <span>Training Enabled:</span>
                                                    <span style={{ color: mlStatus.master_switch ? 'var(--success-green)' : 'var(--text-muted)' }}>
                                                        {mlStatus.master_switch ? 'Yes' : 'No (disabled in code)'}
                                                    </span>
                                                </div>
                                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                    <span>Current Model:</span>
                                                    <span>{mlStatus.config?.current_model || 'None (using local model.pkl)'}</span>
                                                </div>
                                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                    <span>Games Since Last Training:</span>
                                                    <span>{mlStatus.config?.games_since_last_training || 0} / {mlStatus.config?.games_threshold || 200}</span>
                                                </div>
                                                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                    <span>A/B Test Active:</span>
                                                    <span style={{ color: mlStatus.config?.ab_test_active ? 'var(--fire-orange)' : 'var(--text-muted)' }}>
                                                        {mlStatus.config?.ab_test_active ? 'Yes' : 'No'}
                                                    </span>
                                                </div>
                                                {mlStatus.config?.ab_test_active && (
                                                    <>
                                                        <div style={{ marginTop: '1rem', padding: '1rem', background: 'var(--bg-secondary)', borderRadius: '8px' }}>
                                                            <h4 style={{ marginBottom: '0.5rem' }}>A/B Test Progress</h4>
                                                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
                                                                <div>
                                                                    <strong>Model A (Current)</strong><br />
                                                                    Games: {mlStatus.ab_test?.model_a_games || 0} / {mlStatus.config?.ab_test_games_required || 15}<br />
                                                                    Wins: {mlStatus.ab_test?.model_a_wins || 0}
                                                                    {mlStatus.ab_test?.model_a_games > 0 && (
                                                                        <> ({Math.round(mlStatus.ab_test.model_a_wins / mlStatus.ab_test.model_a_games * 100)}%)</>
                                                                    )}
                                                                </div>
                                                                <div>
                                                                    <strong>Model B (Challenger)</strong><br />
                                                                    Games: {mlStatus.ab_test?.model_b_games || 0} / {mlStatus.config?.ab_test_games_required || 15}<br />
                                                                    Wins: {mlStatus.ab_test?.model_b_wins || 0}
                                                                    {mlStatus.ab_test?.model_b_games > 0 && (
                                                                        <> ({Math.round(mlStatus.ab_test.model_b_wins / mlStatus.ab_test.model_b_games * 100)}%)</>
                                                                    )}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </>
                                                )}
                                                <div style={{ marginTop: '1.5rem' }}>
                                                    <h4 style={{ marginBottom: '0.75rem' }}>Training Data Available</h4>
                                                    <div style={{
                                                        display: 'grid',
                                                        gridTemplateColumns: 'repeat(2, 1fr)',
                                                        gap: '0.5rem',
                                                        background: 'var(--bg-secondary)',
                                                        padding: '1rem',
                                                        borderRadius: '8px'
                                                    }}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                            <span style={{ color: 'var(--text-muted)' }}>AI vs Human Games</span>
                                                            <span>{mlStatus.training_data?.ai_vs_human_games || 0}</span>
                                                        </div>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                            <span style={{ color: 'var(--text-muted)' }}>AI Win Rate</span>
                                                            <span>{mlStatus.training_data?.ai_win_rate || 0}%</span>
                                                        </div>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                            <span style={{ color: 'var(--text-muted)' }}>Online Games</span>
                                                            <span>{mlStatus.training_data?.online_games || 0}</span>
                                                        </div>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                                            <span style={{ color: 'var(--text-muted)' }}>Total</span>
                                                            <span>{mlStatus.training_data?.total_games || 0}</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                {!mlStatus.config?.current_model && (
                                                    <button className="btn btn-primary" onClick={uploadOriginalModel} style={{ marginTop: '1rem' }}>
                                                        Upload Original Model to Firebase
                                                    </button>
                                                )}

                                                {/* ML Win Rate Chart */}
                                                {mlStatus.historical_win_rates && mlStatus.historical_win_rates.length > 0 ? (
                                                    <WinRateChart mlStatus={mlStatus} chartTimeframe={chartTimeframe} setChartTimeframe={setChartTimeframe} />
                                                ) : null}
                                            </div>
                                        ) : (
                                            <p style={{ color: 'var(--text-muted)' }}>ML status not available. The /api/ml_manage endpoint may not be deployed.</p>
                                        )}
                                    </div>
                                </div>
                            )}

                            {activeTab === 'overview' && (
                                <>
                                    <div style={{ marginBottom: '1rem', padding: '0.5rem 0' }}>
                                        <span style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                            Statistics (Since Jan 1, 2026)
                                        </span>
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
                                        <div className="home-card" style={{ cursor: 'default' }}>
                                            <h2 className="home-card-title">{stats.uniqueVisitors || 0}</h2>
                                            <p className="home-card-desc">Unique Visitors</p>
                                        </div>
                                        <div className="home-card" style={{ cursor: 'default' }}>
                                            <h2 className="home-card-title" style={stats.aiWinRate === 'ERROR' ? { color: '#ef4444' } : {}}>
                                                {stats.aiWinRate === 'ERROR' ? 'ERROR' : `${stats.aiWinRate || 0}%`}
                                            </h2>
                                            <p className="home-card-desc">AI Win Rate (Since 2026)</p>
                                        </div>
                                        <div className="home-card" style={{ cursor: 'default' }}>
                                            <h2 className="home-card-title" style={stats.aiGames === 'ERROR' ? { color: '#ef4444' } : {}}>
                                                {stats.aiGames === 'ERROR' ? 'ERROR' : (stats.aiGames || 0)}
                                            </h2>
                                            <p className="home-card-desc">Total AI Games</p>
                                        </div>
                                        <div className="home-card" style={{ cursor: 'default' }}>
                                            <h2 className="home-card-title">{stats.avgMatchLength || 0}</h2>
                                            <p className="home-card-desc">Avg Rounds/Game</p>
                                        </div>
                                        <div className="home-card" style={{ cursor: 'default' }}>
                                            <h2 className="home-card-title" style={stats.totalOnlineGames === 'ERROR' ? { color: '#ef4444' } : {}}>
                                                {stats.totalOnlineGames === 'ERROR' ? 'ERROR' : (stats.totalOnlineGames || 0)}
                                            </h2>
                                            <p className="home-card-desc">Online Games</p>
                                        </div>
                                    </div>
                                </>
                            )}

                            {activeTab === 'ai-games' && (
                                <div style={{ background: 'var(--bg-card)', borderRadius: '8px', overflow: 'hidden' }}>
                                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.875rem' }}>
                                        <thead>
                                            <tr style={{ background: 'var(--bg-secondary)', textAlign: 'left' }}>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Timestamp</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Outcome</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Rounds</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Player Moves</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>User ID</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>ML Bot Moves</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Bot ID</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {stats.aiGamesList && stats.aiGamesList.map((game, i) => (
                                                <tr key={i} style={{ borderBottom: '1px solid var(--border-subtle)' }}>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--text-secondary)' }}>{game.timestamp || 'N/A'}</td>
                                                    <td style={{ padding: '0.75rem 1rem', color: game.winner === 'ai' ? 'var(--fire-red)' : '#22c55e' }}>
                                                        {game.winner === 'ai' ? 'AI Won' : 'Human Won'}
                                                    </td>
                                                    <td style={{ padding: '0.75rem 1rem' }}>{game.turns}</td>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--text-secondary)', fontSize: '0.75rem' }}>
                                                        {game.playerMoves?.join(', ') || 'N/A'}
                                                    </td>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--accent-purple)', fontSize: '0.7rem', fontFamily: 'monospace' }}>
                                                        {game.userId ? (game.userId.length > 16 ? game.userId.slice(0, 16) + '...' : game.userId) : 'N/A'}
                                                    </td>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--text-secondary)', fontSize: '0.75rem' }}>
                                                        {game.aiMoves?.join(', ') || 'N/A'}
                                                    </td>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--fire-orange)', fontSize: '0.7rem', fontFamily: 'monospace' }}>
                                                        {game.modelId || 'A'}
                                                    </td>
                                                </tr>
                                            ))}
                                            {(!stats.aiGamesList || stats.aiGamesList.length === 0) && (
                                                <tr><td colSpan="7" style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-secondary)' }}>No games yet</td></tr>
                                            )}
                                        </tbody>
                                    </table>
                                </div>
                            )}

                            {activeTab === 'online-games' && (
                                <div style={{ background: 'var(--bg-card)', borderRadius: '8px', overflow: 'hidden' }}>
                                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.875rem' }}>
                                        <thead>
                                            <tr style={{ background: 'var(--bg-secondary)', textAlign: 'left' }}>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Timestamp</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Player 1</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Player 2</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Winner</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>Rounds</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>P1 Moves</th>
                                                <th style={{ padding: '1rem', borderBottom: '1px solid var(--border-subtle)' }}>P2 Moves</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {stats.onlineGamesList && stats.onlineGamesList.map((game, i) => (
                                                <tr key={i} style={{ borderBottom: '1px solid var(--border-subtle)' }}>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--text-secondary)' }}>{game.timestamp || 'N/A'}</td>
                                                    <td style={{ padding: '0.75rem 1rem', color: game.winner === game.player1 ? '#22c55e' : 'inherit' }}>{game.player1}</td>
                                                    <td style={{ padding: '0.75rem 1rem', color: game.winner === game.player2 ? '#22c55e' : 'inherit' }}>{game.player2}</td>
                                                    <td style={{ padding: '0.75rem 1rem', color: '#22c55e' }}>{game.winner}</td>
                                                    <td style={{ padding: '0.75rem 1rem' }}>{game.turns}</td>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--text-secondary)', fontSize: '0.75rem' }}>
                                                        {game.player1Moves?.join(', ') || 'N/A'}
                                                    </td>
                                                    <td style={{ padding: '0.75rem 1rem', color: 'var(--text-secondary)', fontSize: '0.75rem' }}>
                                                        {game.player2Moves?.join(', ') || 'N/A'}
                                                    </td>
                                                </tr>
                                            ))}
                                            {(!stats.onlineGamesList || stats.onlineGamesList.length === 0) && (
                                                <tr><td colSpan="7" style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-secondary)' }}>No games yet</td></tr>
                                            )}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </>
                    ) : (
                        <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>{stats?.error || 'Error loading stats'}</p>
                    )}
                </div>
            );
        }

        function GuidePage({ onNavigate }) {
            return (
                <div className="guide-container">
                    <div className="game-header">
                        <img src="/fireball_logo.png" alt="" className="game-logo" onClick={() => onNavigate('home')} />
                        <h1 className="game-title">How to Play</h1>
                        <button className="back-btn" onClick={() => onNavigate('home')}>Back to Menu</button>
                    </div>

                    <div className="guide-content">
                        <h2>The Basics</h2>
                        <p>
                            Fireball is a turn-based strategy game where you and your opponent choose moves simultaneously.
                            The goal is simple: play a successful attack on your opponent before they play one on you.
                        </p>

                        <h3>Moves</h3>
                        <ul>
                            <li>
                                <strong>Charge</strong> - Gain 1 energy. You need this energy to play attacks.
                                This is what you need to win, but be careful - you are vulnerable while charging.
                            </li>
                            <li>
                                <strong>Shield</strong> - Blocks all attacks except Megaball. Costs nothing.
                                Use it when you think your opponent is about to attack.
                            </li>
                            <li>
                                <strong>Fireball</strong> - Costs 1 energy. Defeats an opponent who is charging.
                                Gets blocked by Shield and beaten by Iceball.
                            </li>
                            <li>
                                <strong>Iceball</strong> - Costs 2 energy. Defeats Fireball and Charge.
                                Still gets blocked by Shield.
                            </li>
                            <li>
                                <strong>Megaball</strong> - Costs 5 energy. Instantly wins the game.
                                Cannot be blocked. Only canceled out by another Megaball.
                            </li>
                        </ul>

                        <h3>Strategy Tips</h3>
                        <p>
                            The game is all about reading the patterns your opponent makes. If they just used their last charge on an attack,
                            they will probably need to charge again; perfect time for a Fireball. If you have been
                            charging a lot, they might expect an attack and Shield, so maybe charge one more time.
                        </p>

                        <h3>Playing the AI</h3>
                        <p>
                            The ML model has been trained on thousands of games using different algorithms.
                            It learns patterns and will adapt to predictable play. Mix up your strategy and try to win!.
                        </p>

                        <button className="btn btn-primary" onClick={() => onNavigate('play-ai')} style={{ marginTop: '2rem' }}>
                            Start Playing
                        </button>
                    </div>
                </div>
            );
        }

        function PlayAIPage({ onNavigate, userId }) {
            const [sessionId, setSessionId] = useState(null);
            const [game, setGame] = useState({ playerCharges: 0, aiCharges: 0, gameOver: false, winner: null });
            const [history, setHistory] = useState([]);
            const [loading, setLoading] = useState(false);
            const [initializing, setInitializing] = useState(true);
            const [error, setError] = useState(null);

            // Start a new game session on mount
            useEffect(() => {
                startNewSession();
            }, []);

            const startNewSession = async () => {
                setInitializing(true);
                setError(null);

                try {
                    const res = await fetch('/api/game_session?action=start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId })
                    });

                    if (!res.ok) throw new Error('Failed to start session');

                    const data = await res.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    setSessionId(data.sessionId);
                    setGame({
                        playerCharges: data.playerCharges,
                        aiCharges: data.aiCharges,
                        gameOver: false,
                        winner: null
                    });
                    setHistory([]);
                } catch (e) {
                    setError('Failed to start game. Please try again.');
                }

                setInitializing(false);
            };

            const legalMoves = getLegalMoves(game.playerCharges);

            const handleMove = async (move) => {
                if (!sessionId) {
                    setError('No active session. Please refresh the page.');
                    return;
                }

                setLoading(true);
                setError(null);

                try {
                    const res = await fetch('/api/game_session?action=move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            sessionId,
                            move
                        })
                    });

                    if (!res.ok) throw new Error('Request failed');

                    const data = await res.json();

                    if (data.error) {
                        // If session expired/not found, prompt to restart
                        if (data.error.includes('Session') || data.error.includes('expired')) {
                            setError('Session expired. Starting a new game...');
                            setTimeout(() => startNewSession(), 1500);
                        } else if (data.error.includes('Illegal move')) {
                            setError(data.error);
                        } else {
                            throw new Error(data.error);
                        }
                        setLoading(false);
                        return;
                    }

                    setGame({
                        playerCharges: data.playerCharges,
                        aiCharges: data.aiCharges,
                        gameOver: data.gameOver,
                        winner: data.winner
                    });

                    setHistory([{ player: move, ai: data.aiMove, result: data.result }, ...history]);
                } catch (e) {
                    setError('Failed to connect to the AI backend.');
                }

                setLoading(false);
            };

            const resetGame = () => {
                startNewSession();
            };

            if (initializing) {
                return (
                    <div className="game-container">
                        <div className="game-header">
                            <img src="/fireball_logo.png" alt="" className="game-logo" onClick={() => onNavigate('home')} />
                            <h1 className="game-title">vs ML Model</h1>
                            <button className="back-btn" onClick={() => onNavigate('home')}>Back</button>
                        </div>
                        <div style={{ textAlign: 'center', padding: '3rem' }}>
                            <div className="loader"></div>
                            <p style={{ color: 'var(--fire-orange)', marginTop: '1rem', fontSize: '0.9rem' }}>
                                Starting game session...
                            </p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="game-container">
                    <div className="game-header">
                        <img src="/fireball_logo.png" alt="" className="game-logo" onClick={() => onNavigate('home')} />
                        <h1 className="game-title">vs ML Model</h1>
                        <button className="back-btn" onClick={() => onNavigate('home')}>Back</button>
                    </div>

                    {error && <div className="alert">{error}</div>}

                    <div className="charge-display">
                        <div className="charge-block player-charge">
                            <div className="charge-label">Your Charges</div>
                            <div className="charge-value">{game.playerCharges}</div>
                        </div>
                        <div className="charge-block opponent-charge">
                            <div className="charge-label">AI Charges</div>
                            <div className="charge-value">{game.aiCharges}</div>
                        </div>
                    </div>

                    {game.gameOver ? (
                        <div className="end-game">
                            <h2 className={`end-title ${game.winner === 'player1' ? 'win' : 'lose'}`}>
                                {game.winner === 'player1' ? 'You Win' : 'AI Wins'}
                            </h2>
                            <p className="end-subtitle">
                                {game.winner === 'player1'
                                    ? 'Nice work! You beat the model!'
                                    : 'The AI predicted your moves and beat you!'}
                            </p>
                            <button className="btn btn-primary" onClick={resetGame}>Play Again</button>
                        </div>
                    ) : (
                        <div className="moves-grid">
                            {MOVES.map(move => (
                                <button
                                    key={move.id}
                                    className="move-btn"
                                    disabled={loading || !legalMoves.includes(move.id)}
                                    onClick={() => handleMove(move.id)}
                                >
                                    <span>{move.name}</span>
                                    <span className="cost">{move.costDisplay}</span>
                                </button>
                            ))}
                        </div>
                    )}

                    {loading && history.length === 0 && (
                        <>
                            <div className="loader"></div>
                            <p style={{ textAlign: 'center', color: 'var(--fire-orange)', marginTop: '0.5rem', fontSize: '0.9rem' }}>
                                Processing move...
                            </p>
                        </>
                    )}

                    {history.length > 0 && (
                        <div className="history-section">
                            <h3 className="history-title">History</h3>
                            <div className="history-list">
                                {history.map((h, i) => (
                                    <div key={i} className="history-item">
                                        <span style={{ color: 'var(--text-muted)', minWidth: '30px', display: 'inline-block' }}>{history.length - i}</span>
                                        <span>You: <span className="you">{h.player}</span></span>
                                        <span>AI: <span className="opp">{h.ai}</span></span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        function Play1v1Page({ onNavigate, playerId, onlineCount }) {
            const [username, setUsername] = useState('');
            const [status, setStatus] = useState('idle'); // idle, searching, matched, playing, disconnected
            const [matchId, setMatchId] = useState(null);
            const [opponent, setOpponent] = useState('');
            const [gameState, setGameState] = useState(null);
            const [history, setHistory] = useState([]);
            const [loading, setLoading] = useState(false);
            const [pollInterval, setPollInterval] = useState(null);
            const [myMoveSubmitted, setMyMoveSubmitted] = useState(false);
            const [moveSubmitTime, setMoveSubmitTime] = useState(null);
            const [searchStartTime, setSearchStartTime] = useState(null);
            const [showNoPlayersWarning, setShowNoPlayersWarning] = useState(false);
            const [showEndOverlay, setShowEndOverlay] = useState(true);
            const [selectedMove, setSelectedMove] = useState(null);
            const prevGameStatusRef = useRef(null); // Use ref to track previous status (avoids stale closure)

            // Track search duration and show warning if no players found after 10 seconds
            useEffect(() => {
                if (status !== 'searching') {
                    setShowNoPlayersWarning(false);
                    setSearchStartTime(null);
                    return;
                }

                setSearchStartTime(Date.now());

                const checkInterval = setInterval(() => {
                    const elapsed = Date.now() - searchStartTime;
                    if (elapsed > 7000 && onlineCount <= 1) {
                        setShowNoPlayersWarning(true);
                    } else {
                        setShowNoPlayersWarning(false);
                    }
                }, 1000);

                return () => clearInterval(checkInterval);
            }, [status, onlineCount, searchStartTime]);

            // 30-second timeout for opponent moves
            useEffect(() => {
                if (!myMoveSubmitted || !moveSubmitTime) return;

                const checkTimeout = setInterval(() => {
                    const elapsed = Date.now() - moveSubmitTime;
                    if (elapsed > 30000) {
                        clearInterval(checkTimeout);
                        if (pollInterval) clearInterval(pollInterval);
                        setStatus('disconnected');
                        // Notify backend that match is terminated
                        fetch('/api/matchmaking', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'terminate_match',
                                matchId: matchId,
                                playerId: playerId,
                                reason: 'disconnected'
                            })
                        }).catch(e => console.error('Failed to notify termination:', e));
                    }
                }, 1000);

                return () => clearInterval(checkTimeout);
            }, [myMoveSubmitted, moveSubmitTime, pollInterval]);

            // Reset move submission state when turn changes
            useEffect(() => {
                if (gameState?.turn) {
                    setMyMoveSubmitted(false);
                    setMoveSubmitTime(null);
                    setSelectedMove(null);
                }
            }, [gameState?.turn]);

            const findMatch = async () => {
                if (!username.trim()) {
                    alert('Please enter a username');
                    return;
                }

                setStatus('searching');
                setSearchStartTime(Date.now());

                try {
                    const res = await fetch('/api/matchmaking', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'find_match', playerId, username })
                    });

                    const data = await res.json();

                    if (data.status === 'matched') {
                        setMatchId(data.matchId);
                        setOpponent(data.opponent);
                        setStatus('playing');
                        startPolling(data.matchId);
                    } else if (data.status === 'waiting') {
                        startCheckingForMatch();
                    }
                } catch (e) {
                    setStatus('idle');
                    alert('Failed to connect to matchmaking server');
                }
            };

            const startCheckingForMatch = () => {
                const interval = setInterval(async () => {
                    try {
                        const res = await fetch('/api/matchmaking', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'check_match', playerId })
                        });

                        const data = await res.json();

                        if (data.status === 'matched') {
                            clearInterval(interval);
                            setMatchId(data.matchId);
                            setOpponent(data.opponent);
                            setStatus('playing');
                            startPolling(data.matchId);
                        }
                    } catch (e) {
                        console.error('Check match error:', e);
                    }
                }, 2000);

                setPollInterval(interval);
            };

            const startPolling = (mId) => {
                if (window.firestoreDb) {
                    try {
                        import('https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js')
                            .then(({ doc, onSnapshot }) => {
                                console.log('Real-time listener enabled for match:', mId);
                                const matchRef = doc(window.firestoreDb, 'matches', mId);
                                const unsubscribe = onSnapshot(matchRef,
                                    (docSnapshot) => {
                                        if (docSnapshot.exists()) {
                                            const match = docSnapshot.data();
                                            const isPlayer1 = match.player1 === playerId;
                                            const opponentSubmitted = (match.player2_move !== null) ? isPlayer1 : (match.player1_move !== null);
                                            const winner = match.winner;
                                            let didIWin = null;
                                            if (winner) {
                                                didIWin = (isPlayer1 && winner === 'player1') || (!isPlayer1 && winner === 'player2');
                                            }
                                            const newGameState = {
                                                myCharges: isPlayer1 ? match.player1_charges : match.player2_charges,
                                                opponentCharges: isPlayer1 ? match.player2_charges : match.player1_charges,
                                                turn: match.turn,
                                                status: match.status,
                                                winner: match.winner,
                                                didIWin: didIWin,
                                                lastResult: match.last_result,
                                                lastMyMove: isPlayer1 ? match.last_p1_move : match.last_p2_move,
                                                lastOpponentMove: isPlayer1 ? match.last_p2_move : match.last_p1_move,
                                                opponentSubmitted: opponentSubmitted,
                                                opponent: isPlayer1 ? match.player2_username : match.player1_username
                                            };
                                            setGameState(newGameState);
                                            if (newGameState.lastResult && newGameState.lastMyMove) {
                                                setHistory(prev => {
                                                    if (prev.length === 0 || prev[0].you !== newGameState.lastMyMove || prev[0].opp !== newGameState.lastOpponentMove) {
                                                        return [{ you: newGameState.lastMyMove, opp: newGameState.lastOpponentMove }, ...prev.slice(0, 9)];
                                                    }
                                                    return prev;
                                                });
                                            }
                                            // Only show end overlay when status CHANGES to finished (not every update)
                                            if (newGameState.status === 'finished' && prevGameStatusRef.current !== 'finished') {
                                                setShowEndOverlay(true);
                                            }
                                            prevGameStatusRef.current = newGameState.status;
                                        }
                                    },
                                    (error) => {
                                        console.error('Firebase listener error:', error);
                                        startPollingFallback(mId);
                                    }
                                );
                                setPollInterval(unsubscribe);
                                fetchGameState(mId);
                            })
                            .catch(err => {
                                console.warn('Failed to set up Firebase listener:', err);
                                startPollingFallback(mId);
                            });
                    } catch (e) {
                        console.warn('Firebase listener setup failed:', e);
                        startPollingFallback(mId);
                    }
                } else {
                    console.log('Firebase not available, using polling');
                    startPollingFallback(mId);
                }
            };

            const startPollingFallback = (mId) => {
                const interval = setInterval(() => fetchGameState(mId), 1500);
                setPollInterval(interval);
                fetchGameState(mId);
            };

            const fetchGameState = async (mId) => {
                try {
                    const res = await fetch('/api/matchmaking', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'get_game_state', matchId: mId, playerId })
                    });
                    const data = await res.json();
                    setGameState(data);
                    if (data.lastResult && data.lastMyMove) {
                        setHistory(prev => {
                            if (prev.length === 0 || prev[0].you !== data.lastMyMove || prev[0].opp !== data.lastOpponentMove) {
                                return [{ you: data.lastMyMove, opp: data.lastOpponentMove }, ...prev.slice(0, 9)];
                            }
                            return prev;
                        });
                    }

                    // Only show end overlay when status CHANGES to finished
                    if (data.status === 'finished' && prevGameStatusRef.current !== 'finished') {
                        if (typeof pollInterval === 'function') {
                            pollInterval();
                        } else {
                            clearInterval(pollInterval);
                        }
                        setShowEndOverlay(true);
                    }
                    prevGameStatusRef.current = data.status;
                } catch (e) {
                    console.error('Fetch state error:', e);
                }
            };

            const submitMove = async (move) => {
                setLoading(true);
                setMyMoveSubmitted(true);
                setSelectedMove(move);
                setMoveSubmitTime(Date.now());

                try {
                    await fetch('/api/matchmaking', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'submit_move', matchId, playerId, move })
                    });
                } catch (e) {
                    console.error('Submit move error:', e);
                }

                setLoading(false);
            };

            const leaveQueue = async () => {
                if (pollInterval) clearInterval(pollInterval);

                await fetch('/api/matchmaking', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'leave_queue', playerId })
                });

                setStatus('idle');
            };

            const resetMatch = () => {
                if (pollInterval) {
                    if (typeof pollInterval === 'function') {
                        pollInterval();
                    } else {
                        clearInterval(pollInterval);
                    }
                }
                setStatus('idle');
                setMatchId(null);
                setOpponent('');
                setGameState(null);
                setHistory([]);
                setMyMoveSubmitted(false);
                setSelectedMove(null);
                setMoveSubmitTime(null);
                setSearchStartTime(null);
                setShowNoPlayersWarning(false);
                setShowEndOverlay(true);
                prevGameStatusRef.current = null;
            };

            useEffect(() => {
                return () => {
                    if (pollInterval) {
                        if (typeof pollInterval === 'function') {
                            pollInterval();
                        } else {
                            clearInterval(pollInterval);
                        }
                    }
                };
            }, [pollInterval]);

            // Clean up matchmaking queue on tab close
            useEffect(() => {
                const handleBeforeUnload = () => {
                    // If player is searching or in a match, clean up
                    if (status === 'searching' || status === 'playing') {
                        // Use sendBeacon for reliable cleanup on page unload
                        const payload = JSON.stringify({
                            action: 'leave_queue',
                            playerId
                        });

                        // Try sendBeacon first (most reliable for unload)
                        const blob = new Blob([payload], { type: 'application/json' });
                        navigator.sendBeacon('/api/matchmaking', blob);
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);

                return () => {
                    window.removeEventListener('beforeunload', handleBeforeUnload);
                    // Also clean up when component unmounts
                    if (status === 'searching' || status === 'playing') {
                        fetch('/api/matchmaking', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'leave_queue', playerId }),
                            keepalive: true
                        }).catch(() => { });
                    }
                };
            }, [status, playerId]);


            const myCharges = gameState?.myCharges || 0;
            const legalMoves = getLegalMoves(myCharges);

            // Check if we're waiting for opponent (we submitted but they haven't)
            const waitingForOpponent = myMoveSubmitted && gameState && !gameState.opponentSubmitted && gameState.status !== 'finished';

            // Online badge component
            const OnlineBadge = () => (
                <div className="online-badge">
                    <span className="online-dot"></span>
                    <span>{onlineCount} player{onlineCount !== 1 ? 's' : ''} online</span>
                </div>
            );

            return (
                <div className="game-container">
                    <div className="game-header">
                        <img src="/fireball_logo.png" alt="" className="game-logo" onClick={() => { leaveQueue(); onNavigate('home'); }} />
                        <div>
                            <h1 className="game-title">Play Online</h1>
                            {gameState?.status === 'finished' && !showEndOverlay && (
                                <button className="btn btn-primary play-again-header" onClick={resetMatch}>Play Again</button>
                            )}
                        </div>
                        <button className="back-btn" onClick={() => { leaveQueue(); onNavigate('home'); }}>Back</button>
                    </div>

                    {status === 'idle' && (
                        <div className="matchmaking-status">
                            <OnlineBadge />
                            <p>Enter a username to find an opponent</p>
                            <input
                                type="text"
                                className="input-field"
                                placeholder="Username"
                                value={username}
                                onChange={e => setUsername(e.target.value)}
                                onKeyDown={e => e.key === 'Enter' && findMatch()}
                            />
                            <br />
                            <button className="btn btn-primary" onClick={findMatch}>Find Match</button>
                        </div>
                    )}

                    {status === 'searching' && (
                        <div className="matchmaking-status">
                            <OnlineBadge />
                            <p>Searching for an opponent...</p>
                            <div className="loader"></div>
                            <button className="btn btn-secondary" onClick={leaveQueue} style={{ marginTop: '1rem' }}>Cancel</button>
                            {showNoPlayersWarning && (
                                <div className="warning-box">
                                    Looks like there isn't anyone online. It might take a while to find an opponent.
                                </div>
                            )}
                        </div>
                    )}

                    {status === 'disconnected' && (
                        <div className="disconnected-overlay">
                            <h2>Opponent Disconnected :&#40;</h2>
                            <p>Your opponent took too long to respond and the match has been terminated.</p>
                            <button className="btn btn-primary" onClick={resetMatch}>Find New Match</button>
                        </div>
                    )}

                    {status === 'playing' && gameState && (
                        <>
                            <p style={{ textAlign: 'center', color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                Playing against <strong style={{ color: 'var(--accent-purple)' }}>{opponent}</strong>
                                {gameState.opponentSubmitted && !myMoveSubmitted && <span> - Waiting for you</span>}
                            </p>

                            <div className="charge-display">
                                <div className="charge-block player-charge">
                                    <div className="charge-label">Your Charges</div>
                                    <div className="charge-value">{gameState.myCharges}</div>
                                </div>
                                <div className="charge-block opponent-charge">
                                    <div className="charge-label">{opponent}'s Charges</div>
                                    <div className="charge-value">{gameState.opponentCharges}</div>
                                </div>
                            </div>

                            <div className="moves-grid">
                                {MOVES.map(move => {
                                    const isSelected = selectedMove === move.id;
                                    const isFaded = myMoveSubmitted && !isSelected;
                                    const isFinished = gameState.status === 'finished';

                                    return (
                                        <button
                                            key={move.id}
                                            className={`move-btn ${isSelected ? 'selected' : ''} ${isFaded || isFinished ? 'faded' : ''}`}
                                            disabled={loading || !legalMoves.includes(move.id) || myMoveSubmitted || isFinished}
                                            onClick={() => submitMove(move.id)}
                                        >
                                            <span>{move.name}</span>
                                            <span className="cost">{move.costDisplay}</span>
                                        </button>
                                    );
                                })}
                            </div>

                            {waitingForOpponent && (
                                <div className="waiting-overlay" style={{ marginTop: '2rem', border: 'none', background: 'transparent', padding: '0' }}>
                                    <div className="waiting-dots">
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                    </div>
                                    <p className="waiting-text">Waiting for {opponent} to make a move...</p>
                                </div>
                            )}

                            {history.length > 0 && (
                                <div className="history-section">
                                    <h3 className="history-title">Log</h3>
                                    <div className="history-list">
                                        {history.map((h, i) => (
                                            <div key={i} className="history-item">
                                                <span style={{ color: 'var(--text-muted)', minWidth: '30px', display: 'inline-block' }}>{history.length - i}</span>
                                                <span>You: <span className="you">{h.you}</span></span>
                                                <span>{opponent}: <span className="opp">{h.opp}</span></span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {gameState.status === 'finished' && showEndOverlay && (
                                <div className={`end-game-overlay ${gameState.didIWin ? 'win' : 'lose'}`}>
                                    <button
                                        className="close-overlay-btn"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            setShowEndOverlay(false);
                                        }}
                                        aria-label="Close"
                                    >âœ•</button>
                                    <div className="end-game-content">
                                        <div className={`end-icon ${gameState.didIWin ? 'win' : 'lose'}`}>
                                            {gameState.didIWin ? 'ðŸ”¥' : 'â„ï¸'}
                                        </div>
                                        <h2 className={`end-title ${gameState.didIWin ? 'win' : 'lose'}`}>
                                            {gameState.didIWin ? 'Victory!' : 'Defeat'}
                                        </h2>
                                        <p className="end-subtitle">
                                            {gameState.didIWin
                                                ? `You defeated ${opponent}!`
                                                : `${opponent} won this round`
                                            }
                                        </p>
                                        <div className="end-actions">
                                            <button
                                                className="btn btn-primary play-again-btn"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    resetMatch();
                                                }}
                                            >
                                                Play Again
                                            </button>
                                            <button
                                                className="btn btn-secondary"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    setShowEndOverlay(false);
                                                }}
                                            >
                                                View Game
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }


        function App() {
            const getPageFromUrl = () => {
                const path = window.location.pathname;
                if (path === '/guide') return 'guide';
                if (path === '/playai') return 'play-ai';
                if (path === '/online') return 'play-1v1';
                if (path === '/admin') return 'admin';
                return 'home';
            };

            const [page, setPage] = useState(getPageFromUrl());
            const [onlineCount, setOnlineCount] = useState(0);
            const [isMaintenanceMode, setIsMaintenanceMode] = useState(false);
            const [maintenanceMessage, setMaintenanceMessage] = useState('');
            const [checkingMaintenance, setCheckingMaintenance] = useState(true);

            // Use sessionStorage for per-tab playerId (allows testing matchmaking in multiple tabs)
            // Each tab gets a unique session ID for matchmaking purposes
            const [playerId] = useState(() => {
                let id = sessionStorage.getItem('fireball_session_id');
                if (!id) {
                    id = 'player_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    sessionStorage.setItem('fireball_session_id', id);
                }
                return id;
            });

            // Persistent userId for tracking unique browsers (survives browser close)
            const [userId] = useState(() => getOrCreateUserId());

            // Check maintenance mode on startup
            useEffect(() => {
                const checkMaintenance = async () => {
                    try {
                        const res = await fetch('/api/auth?action=config');
                        const data = await res.json();
                        setIsMaintenanceMode(data.maintenance_mode || false);
                        setMaintenanceMessage(data.maintenance_message || 'Site undergoing temporary maintenance. Please check back later.');
                    } catch (e) {
                        // If we can't reach the server, don't block users
                        console.log('Could not check maintenance status');
                    }
                    setCheckingMaintenance(false);
                };

                checkMaintenance();
            }, []);

            // URL routing
            const navigate = (newPage) => {
                const paths = {
                    'home': '/',
                    'guide': '/guide',
                    'play-ai': '/playai',
                    'play-1v1': '/online',
                    'admin': '/admin'
                };
                window.history.pushState({}, '', paths[newPage] || '/');
                setPage(newPage);
            };

            // Handle browser back/forward
            useEffect(() => {
                const handlePopState = () => {
                    setPage(getPageFromUrl());
                };
                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, []);

            // Heartbeat for online players tracking (on all pages except admin)
            useEffect(() => {
                if (page === 'admin' || isMaintenanceMode) return;

                const sendHeartbeat = async () => {
                    try {
                        await fetch('/api/matchmaking', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'heartbeat', playerId })
                        });

                        const res = await fetch('/api/matchmaking', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'get_online_count' })
                        });
                        const data = await res.json();
                        setOnlineCount(data.count || 0);
                    } catch (e) {
                        console.log('Heartbeat error');
                    }
                };

                sendHeartbeat();
                const interval = setInterval(sendHeartbeat, 5000);
                return () => clearInterval(interval);
            }, [playerId, page, isMaintenanceMode]);

            // Show loading while checking maintenance
            if (checkingMaintenance) {
                return (
                    <div className="app" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '100vh' }}>
                        <div className="loader"></div>
                    </div>
                );
            }

            // Check maintenance mode first (allow admin to still access dashboard)
            if (isMaintenanceMode && page !== 'admin') {
                return <MaintenancePage message={maintenanceMessage} />;
            }

            return (
                <div className="app">
                    {page === 'home' && <HomePage onNavigate={navigate} />}
                    {page === 'guide' && <GuidePage onNavigate={navigate} />}
                    {page === 'play-ai' && <PlayAIPage onNavigate={navigate} userId={userId} />}
                    {page === 'play-1v1' && <Play1v1Page onNavigate={navigate} playerId={playerId} onlineCount={onlineCount} />}
                    {page === 'admin' && <AdminPage onNavigate={navigate} />}
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>